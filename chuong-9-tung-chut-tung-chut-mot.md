# Chương 9: Từng chút từng chút một

Khi Tony Orlando nhắn nhủ người thương của mình trong một ca khúc năm 1973 "Tie a Yellow Ribbon Round the Ole Oak Tree", ông không đòi hỏi những lời giải bài tỉ mỉ hay thảo luận gì thêm. Ông không muốn nhưng nhị gì hết. Mặc dù bên cạnh những xúc cảm phức tạp và nguồn gốc đầy xúc động khi bài hát được viết dựa trên một câu chuyện có thật, thì với cánh đàn ông tất cả những gì họ muốn chỉ là một câu trả lời có hoặc không. Cậu ta muốn một sợi ruy-băng vàng thắt quanh cây  mang nghĩa là "Vâng, mặc dù anh gây ra nhiều vụ lộn xộn và đã vào tù ba năm, thì em vẫn muốn anh quay trở về dưới mái nhà này bên em". Và muốn sự vắng mặt dải ruy-băng vàng ấy có nghĩa là"Đừng có mà _nghĩ_ tới việc dừng lại tại đây nhá".

Đây là hai sự lựa chọn đối lập. Tony Orlando đã _không_ hát, "Tie half of a yellow ribbon if you want to think about it for a while" hay "Tie a blue ribbon if you don't love me anymore but you'd still like to be friends." Thay vì vậy, ông đã làm việc đó rất rất đơn giản.

Tác dụng cân đối khi có hay vắng mặt dải ruy-băng vàng \(nhưng có lẽ là sẽ khá ngượng nghịu khi đặt vào thơ\) có thể là một sự lựa chọn cho tín hiệu giao thông trước sân: Có lẽ là "Nhập làn" hay "Sai Đường".

Hay một biển báo treo trên cửa: "Đóng" hay "Mở".

Hay một cây đèn pin trong cửa sổ, được bật hay tắt.

Bạn có thể chọn trong cả đống cách để nói có hay không nếu đó là tất cả những gì bạn muốn nói. Bạn không cần cả một câu để nói có hay không; bạn không cần một từ và cũng chẳng cần lấy một chữ. Những gì bạn cần là một _bit_, và tôi nói vậy có nghĩa là thứ mà bạn cần chỉ là 0 và 1.

Như ta đã khám phá trong các chương trước, chẳng có gì là đặc biệt với hệ thập phân mà ta dùng để tính toán cả. Khá là rõ ràng rằng chúng ta tạo ra hệ chữ số dựa trên mười bởi vì đó là số ngón tay mà ta có. Cũng có thể hệ số của ta sẽ dựa trên tám \(nếu chúng ta là các nhân vật hoạt hình\) hay bốn \(nếu ta là tôm hùm\) hay thậm chí là hai \(nếu ta là cá heo\).

Nhưng lại _có_ một điều đặc biệt về hệ số nhị phân. Đó là nó là hệ số đơn giản nhất có thể có. Chỉ có duy nhất hai chữ số nhị phân - 0 và 1. Nếu ta muốn đơn giản hơn, ta sẽ bỏ luôn số 1, và khi đó chỉ còn lại mỗi số 0. Mà ta chẳng làm được gì nhiều với mình nó cả.

Từ _bit_, đặt ra mang nghĩa là _số nhị phân_, chắc hẳn nó là một trong những từ dễ thương nhất đã được phát minh mà liên quan tới máy tính. Tất nhiên, từ đó có một nghĩa thường, "một khoảng, đơn vị, độ nhỏ", và cái nghĩa thông thường ấy hoàn hảo là bởi một bit - một số nhị phân - thật ra là một lượng rất nhỏ.

Lắm lúc khi một từ mới được nghĩ ra, nó cũng mang một nghĩa mới. Và cũng đúng trong trường hợp này. Một bit có một nghĩa vượt trên các chữ số nhị phân cho cá heo tập đếm. Trong thời đại máy tính, bit được xem như là _khối cấu trúc cơ bản của thông tin_.

Giờ thì đó là một lời tuyên bố táo bạo, và tất nhiên, các bit không phải là thứ duy nhất truyền thông tin. Chữ cái, từ ngữ, mã Morse, mã Braille và các chữ số thập phân cũng chuyên chở thông tin tốt vậy. Điều đặc biệt ở bit đó là nó truyền một lượng thông tin rất nhỏ. Một bit thông tin là một lượng thông tin nhỏ nhất có thể. Bất kể thứ gì ít hơn một bit thì không mang chút thông tin nào cả. Nhưng vì một bit đại diện cho một lượng thông tin nhỏ nhất có thể, nên những thông tin phức tạp hơn có thể được truyền đi với nhiều bit hơn. \(Khi nói một bit truyền đi một lượng nhỏ thông tin, hẳn là tôi không có ý là thông tin này gần như không quan trọng. Thực tế thì, dải ruy-băng vàng là một bit _rất_ quan trọng với hai người quan tâm đến nó.\)

Henry Wadsworth Longfellow đã viết "Listen, my children, and you shall hear / Of the midnight ride of Paul Revere" và trong khi ông ta có thể không chính xác về mặt lịch sử khi miêu tả cách mà Paul Revere đã báo hiệu cho người Mỹ về sự xâm lược của Anh, ông đã cung cấp một ví dụ đáng để suy nghĩ về việc sử dụng các bit để truyền đạt thông tin quan trọng:

He said to his friend "If the British march  
By land or sea from the town to-night,  
Hang a lantern aloft in the belfry arch  
Of the North Church tower as a special light,-  
One, if by land, and two, if by sea..."

Anh ta nhắn đám bạn mình  
Nếu đêm tụi Anh điều binh từ thành  
Vượt rừng băng biển chẳng lành  
Thì treo ngọn đèn trong vành tháp chuông  
Trên nhà thờ bắc theo khuôn -   
Một cho đi bộ đi xuồng thì hai..."

Thơ mình dịch cho dễ hiểu =\)\)

Tóm gọn lại, cậu bạn của Paul Revere có hai cái đèn lồng. Nếu lính Anh xâm lược bằng đường bộ, thì cậu ta chỉ đặt một cái đèn vào trong tòa tháp nhà thờ. Nếu lính Anh đi đường biển, thì cậu ta sẽ đặt luôn hai cái.

Tuy nhiên, Longfellow không công khai nhắc đến tất cả các tình huống có thể xảy ra. Ông để ngỏ khả năng thứ ba, đó là lính Anh vẫn chưa xâm chiếm. Longfellow ngầm nhắn là trường hợp này sẽ được truyền tin bằng sự vắng mặt của các ngọn đèn trong thành nhà thờ.

Hãy giả sử rằng hai cái đèn lồng thực tế được gắn chặt vào trong tòa tháp nhà thờ. Những lúc bình thường thì chúng không được thắp sáng:

Điều đó có nghĩa là lính Anh vẫn chưa đến. Nếu một trong các ngọn đèn được thắp thì,

lính Anh đang đến bằng đường bộ. Nếu cả hai đèn đều được thắp sáng,

thì lính Anh đến bằng đường biển.

Mỗi chiếc đèn là một bit. Đèn sáng là 1 bit và không sáng là 0 bit. Tony Orlando đã chứng minh cho chúng ta thấy là chỉ cần một bit là đã có thể truyền đi một trong hai tình huống có thể có. Nếu Paul Revere chỉ cần báo động rằng lính Anh đang đến \(và không biết đi bằng đường nào hết\), thì một cái đèn thôi đã đủ rồi. Đèn sẽ được thắp sáng cho một cuộc xâm lăng và không thắp cho một đêm bình yên nữa.

Truyền đi một trong ba tình huống thì cần phải có thêm một cái đèn khác. Tuy nhiên, một khi có thêm cái đèn thứ hai thì, với hai bit lại có thể truyền đi bốn trường hợp lận:

00 = Anh sẽ không chiếm đánh tối nay.  
01= Chúng đến bằng đường bộ.  
10 = Chúng đến bằng đường bộ.  
11 = Chúng đến bằng đường thủy.

Những gì Paul Revere đã làm bằng việc chỉ ra chỉ ba trường hợp thì thực ra là khá hợp lý. Trong ngôn ngữ của thuyết truyền tin, ông dùng từ _rườm rà_ để trung hòa ảnh hưởng của từ _nhiễu_. Từ nhiễu được dùng trong lý thuyết giao tiếp để ám chỉ bất cứ thứ gì can thiệp sự truyền tin. Tính tĩnh trên đường dây điện thoại là một ví dụ rõ ràng về việc nhiễu can thiệp vào các cuộc giao tiếp điện thoại. Truyền tin thông qua điện thoại thì thường đều thành công, mặc dù, thậm chí là bị nhiêcu bởi vì ngôn ngữ nói rườm rà cực kì. Chúng ta không cần phải nghe mọi âm tiết của một từ để mà hiểu hết những gì được nói ra.

Trong trường hợp các chiếc đèn trong tháp nhà thờ, nhiễu có thể được ám chỉ đến bóng tối và khoảng cách của Paul Revere từ tòa tháp, cả hai có thể làm cản trở cậu ta phân biệt cái đèn này với cái đèn kìa. Đây là đoạn cốt yếu trong bài thơ của Longfellow:

And lo! As he looks, on the belfry's height  
A glimmer, and then a gleam of light!  
He springs to the saddle, the bridle he turns,  
But lingers and gazes, till full on his sight  
A second lamp in the belfry burns!

Và xem kìa, anh nhìn về tháp chuông  
Một tia nhấp nháy nhẹ tuôn  
Anh nắm dây cương phóng luôn lên ngựa  
Nhưng chần chừ và lơ đãng  
Một ngọn đèn khác lại sáng trên chuông!

Chắc hẳn trông không như là Paul Revere đang trong tình huống có thể nhận ra chính xác cái đèn nào được thắp sáng trước.

Khái niệm thiết yếu ở đây là _thông tin đại diện cho một sự lựa chọn trong hai hay nhiều lựa chọn có thể có_. Ví dụ, khi chúng ta nói chuyện với người khác, mọi từ mà ta nói là một sự lựa chọn giữa tất cả các từ có trong từ điển. Nếu chúng ta đếm tất cả các từ trong từ điển từ 1 tới 351.482, thì ta có thể tiếp tục các cuộc trò chuyện khác bằng cách dùng số mà có vẻ lại chính xác hơn cả dùng chữ. \(Tất nhiên, cả hai người nói chuyện đều cần từ điển mà các từ được đánh số sẵn, kèm theo một nùi kiên nhẫn\).

Mặt trái của điều này là _mọi thông tin nào đều có thể giảm đi thành một lựa chọn trong hai hay nhiều khả năng có thể được diễn ta bằng cách sử dụng bit_. Không cần phải nói, có rất nhiều dạng giao tiếp của con người mà _không_ cần đại diện các sự lựa chọn trong các khả năng riêng lẻ và chúng cũng quan trọng cho sự tồn tại của chúng ta. Đây là lý do tại sao con người không hình thành các mối quan hệ lãng mạn với máy tính. \(Dù gì thì cũng hãy hy vọng rằng bọn họ sẽ không như vậy\). Nếu bạn không thể diễn tả thứ gì đó bằng từ ngữ, hình ảnh hay âm thanh, bạn sẽ không có khả năng mã hóa các thông tin thành các bit. Mặc dù bạn muốn như vậy.

Ngón cái chỉ lên hay chỉ xuống là một bit thông tin. Và hai ngón cái chỉ lên hoặc chỉ xuống - như của các nhà phê bình phim Roger Ebert và sau này là Gên Siskel khi họ đưa ra các nhận định cuối cùng về các bộ phim mới nhất - truyền đi hai bit thông tin. \(Chúng ta sẽ bỏ qua những gì họ thực sự nói về các bộ phim; những gì chúng ta quan tâm ở đây là các ngón cái của họ\) Ở đây ta có bốn khả năng có thể đại diện bởi một nhóm các bit:

00 = Bọn họ đều ghét nó.  
01 = Siskel ghét nó; Ebert thích nó.  
10 = Siskel thích nó; Ebert ghét nó.  
11 = Bọn họ đều thích nó.

Bit đầu tiên là bit Siskel, là 0 nếu Siskel ghét bộ phim và là 1 nếu ông ta thích nó. Tương tự, bit thứ hai là bit Ebert.

Thế nên nếu cậu bạn của bạn có hỏi, "Siskel và Ebert nhận xét gì về bộ phim _Impolite Encounter_?" thay vì trả lời, "Siskel cho nó ngón cái chỉ lên và Ebert cho nó ngón cái chỉ xuống" hay thậm chí "Siskel thích nó Ebert thì không" bạn có thể đơn giản chỉ nói" Một không". Chừng nào bạn của bạn biết cái nào là bit Siskel và cái nào là bit Ebert, và bit 1 nghĩa là thích bit 0 nghĩa là không thích thì câu trả lời của bạn là hoàn toàn dễ hiểu. Nhưng bạn và bạn ấy phải biết về code.

Ta có thể định trước rằng bit 1 mang nghĩa là không thích và bit không có nghĩa là thích. Điều đó có vẻ là ngược đời. Lẽ thường, chúng ta thích nghĩ về 1 như là đại diện cho thứ gì đó có vẻ khẳng định và 0 thì ngược lại, nhưng nó chỉ là một phép gán tùy hứng thôi. Yêu cầu duy nhất là mọi người dùng mã phải biết các bit 1 và 0 mang nghĩa gì.

Ý nghĩa của một bit cụ thể hay một nhóm các bit luôn luôn được hiểu theo ngữ cảnh. Ý nghĩa của dải ruy-băng vàng quấn quanh một cây sồi cụ thể có thể chỉ được biết với một người đã đặt nó ở đó và người được cho là sẽ thấy nó. Thay đổi màu sắc, cái cây hay ngày và nó sẽ thành một miểng vải vô nghĩa. Tương tự, để có một vài thông tin hữu ích từ cử chỉ của Siskel và Ebert, ít nhất chúng ta cần biết bộ phim nào được bàn luận.

Nệu bạn giữ một danh sách các bộ phim mà Siskel và Ebert đã nhận xét và cách mà họ bình chọn với các ngọn cái của họ, bạn có thể thêm một bit khác để trộn thêm ý kiến của chính mình. Thêm một bit thứ ba làm tăng số các khả năng lên tám:

000 = Siskel ghét nó; Ebert ghét nó; Tôi ghét nó.  
001 = Siskel ghét nó; Ebert ghét nó; Tôi thích nó.  
010 = Siskel ghét nó; Ebert thích nó; Tôi ghét nó.  
011 = Siskel ghét nó; Ebert thích nó; Tôi thích nó.  
100 = Siskel thích nó; Ebert ghét nó; Tôi ghét nó.  
101 = Siskel thích nó; Ebert ghét nó; Tôi thích nó.  
110 = Siskel thích nó; Ebert thích nó; Tôi ghét nó.  
111 = Siskel thích nó; Ebert thích nó; Tôi thích nó.

Một điểm cộng của việc dùng các bit đại diện cho thông tin là chúng ta biết rằng chúng ta tính được các khả năng có thể có. Chúng ta biết có thể có tám và chỉ tám khả năng và không thêm bớt gì nữa. Với 3 bit, chúng ta chỉ đếm được từ 0 tới 7. Không có thêm các số nhị phân 3 chữ số nào nữa cả.

Nào, trong suốt bảng mô tả về các bit của Siskel và Ebert, bạn có thể sẽ đặt một câu hỏi rất nghiêm túc và đáng ngại, và đó là: Chúng ta làm gì với _Leonard Maltin's Movie & Video Guide_? Sau cùng, Leonard Maltin không đưa ngón cái lên hay xuống. Leonard Maltin xếp hạng các cuốn phim bằng việc dùng hệ thống ngôi sao truyền thống hơn.

Để xác định có bao nhiêu bit Maltin, chúng ta trước hết phải biết một ít về hệ thống của ông. Maltin cho một cuộn phim bất kì từ 1 tới 4 sao, với nửa sao ở giữa. \(Để làm cho thú vị hơn, ông thật ra không cho một sao không thôi; thay vào đó cuốn phim được xếp hạng là BOMB.\) Có bảy khả năng, điều đó có nghĩa là ta có thể đại diện một mức xếp loại chỉ bằng 3 bit:

000 = BOMB  
001 = \*1/2  
010 = \*\*  
011 = \*\*1/2  
100 = \*\*\*  
101 = \*\*\*1/2  
110 = \*\*\*\*

"Còn 111 thì sao?" bạn có thể sẻ hỏi vậy. Chà, mã này chẳng có nghĩa gì cả. Nó không được định nghĩa. Nếu mã nhị phân 111 được dùng để đại diện cho xếp hạng của Maltin, bạn biết rằng đó là một lỗi. \(Có lẽ lỗi này là do máy tính gây ra chứ con người không bao giờ làm thế.\)

Bạn sẽ nhớ lại rằng khi chúng ta có hai bit đại diện cho xếp hạng Siskel và Ebert, bit bên trái là bit Siskel và bit bên phải là bit Ebert. Các bit riêng lẽ có phải mang một nghĩa nào đó ở đây không? Chà, cũng đại loại vậy. Nếu bạn lấy các giá trị số của mã bit, cộng thêm 2 và chia cho 2, sẽ cho ra số lượng các sao. Nhưng đó chỉ là vì chúng ta định nghĩa các mã theo một lối hợp lý và nguyên tắc. Chúng ta cũng có thể định ngĩa các mã theo cách này:

000 = \*\*\*  
001 = \*1/2  
010 = \*\*1/2  
011 = \*\*\*\*  
101 = \*\*\*1/2  
110 = \*\*  
111 = BOMB

Mã này cũng hợp lý như mã trên chừng nào mọi người đều biết ý nghĩa của nó.

Nếu Maltin có bắt gặp một bộ phim nào còn tệ hơn mức một sao, ông ta có thể cho nó nửa sao. Ông chắc chắn sẽ có đủ mã cho lựa chọn nửa sao. Mã có thể được định nghĩa như sau:

000 = MAJOR BOMB  
001 = BOMB  
010 = \*1/2  
011 = \*\*  
100 = \*\*1/2  
101 = \*\*\*  
110 = \*\*\*1/2  
111 = \*\*\*\*

Nhưng nếu sau đó ông còn gặp thêm một bộ phim còn chả đáng được nửa sao và quyết định cho nó không sao \(ATOMIC BOMB?\), ông cần thêm một bit khác nữa. Không còn đủ mã 3-bit cho ông.

Tạp chí _Entertainment Weekly_ phân chia thứ bậc, không chỉ cho các cuốn phim mà còn cho các chương trình truyền hình, đĩa CD, sách, CD-ROM, các trang web, và nhiều thứ khác nữa. Khoảng thứ bậc từ A+ trở xuống F \(mặc dù có vẻ như chỉ có các cuốn phim của Pauly Shore mới đáng nhận vinh dự này\). Nếu bạn đếm chúng, bạn thấy rằng có 13 thứ bậc khả thi. Chúng ta sẽ cần 4 bit để đại diện cho các bậc này:

0000 = F  
0001 = D-  
0010 = D  
0011 = D+  
0100 = C-  
0101 = C  
0110 = C+  
0111 = B-  
1000 = B  
1001 = B+  
1010 = A-  
1011 = A  
1100 = A+

Chúng ta còn ba mã chưa được dùng: 1101, 1110 và 1111, cho tổng cộng 16 mã.

Cứ khi nào ta nói về các bit, chúng ta thường nói về các con số bit cụ thể. Ta càng có nhiều bit, thì càng có nhiều khả năng chúng ta có thể truyền tải được.

Chuyện này cũng giống với hệ thập phân, tất nhiên rồi. Ví dụ, có bao nhiêu mã vùng điện thoại? Mã vùng là con số có ba chữ số thập phân, và nếu tất cả chúng đều được dùng \(mà thật ra là không, nhưng ta cứ cho qua đi\), thì có 103, hay 1000 mã, từ 000 tới 999. Có bao nhiêu số điện thoại 7 chữ số có thể có với mã vùng 212? Đó là 107, hay 10.000.000. Có bao nhiêu số điện thoại mà bạn có thể có được với mã vùng 212 và đầu số 260? Đó là 104, hay 10,000.

Tương tự như vậy, trong hệ nhị phân số các mã khả thi thì luôn luôn bằng với 2 lũy thừa số lượng các bit:

Cứ thêm một bit thì sẽ có gấp đôi mã.

Nếu bạn biết cần dùng bao nhiêu mã, thì bạn sẽ phải tính số bit như thể nào? Hay nói cách khác, làm sao để bạn làm ngược lại với bảng trên?

Phương pháp bạn dùng sẽ là logarit cơ số 2. Phép logarit đi ngược lại với phép lũy thừa. Chúng ta biết rằng 2 lũy thừa 7 bằng 128. Và log cơ số 2 của 128 thì bằng 7. Để dùng ký hiệu toán học thì ta có mệnh đề:

27 = 128

tương đương với

log2128 = 7

Vậy nếu log cơ số 2 của 128 bằng 7 và log cơ số 2 của 256 bằng 8, thì rồi log cơ số 2 của 200 là bao nhiêu? Chính xác thì là 7.64, nhưng chúng ta thực ra không phải biết vậy. Nếu chúng ta cần đại diện 200 thứ khác nhau bằng các bit thì ta sẽ cần 8 bit.

Các bit thường được ẩn vào sâu bên trong các dụng cụ điện của chúng ta. Chúng ta không thể thấy các bit được mã hóa trong các đĩa cứng, trong các đồng hồ điện tử hay trong máy tính của ta. Nhưng đôi khi các bit lại được nhìn thấy rõ ràng.

Dưới đây là một ví dụ. Nếu bạn sở hữu cuộn phim35-milimet, thì hãy nhìn vào cuộn phim xem. Giữ nó như thế này:

Bạn sẽ thấy một lưới như bàn cờ với các ô vuông bạc và đen mã tôi đã đánh số từ 1 tới 12 như trong sơ đồ. Cái này được gọi là _DX-encoding_. 12 ô vuông này thực tế là 12 bit. Một ô vuông bạc nghĩa là bit 1 và ô vuông đen là bit 0. Ô 1 và ô 7 luôn luôn là bạc \(1\).

Các bit này ẩn chứa ý nghĩa gì bên trong? Bạn có thể nhận thấy một vài cuộn film nhạy với ánh sáng hơn các cuộn khác. Tính nhạy sáng thì thường được gọi là _tốc độ_ phim. Một cuốn phim mà rất nhạy với ánh sáng được gọi là nhanh bởi vì chúng có thể được phơi sáng rất nhanh. Tốc độ của cuộn phim được chỉ ra bởi xếp hạng ASA \(American Standards Association\), phổ biến nhất là 100, 200 và 400. Xếp hạng ASA này không chỉ được in trên vỏ hộp và phim cát-xét mà còn được mã hóa thành các bit.

Có 24 xếp hạng ASA tiêu chuẩn cho phim ảnh. Chúng đây:

Có bao nhiêu bit được yêu cầu để mã hóa thành xếp hạng ASA? Câu trả lời là 5. Chúng ta biết rằng 24 bằng 16, vậy nên sẽ ít quá. Nhưng 2^5 bằng 322, thì thích hợp hơn.

Các bit tương ứng với tốc độ phim được bày ra trong bảng sau:

Đa phần các máy ảnh hiện đại 35-miimet dùng các mã này. \(Ngoại trừ các máy ảnh mà trên đó bạn phải cài đặt độ phơi sáng bằng tay và các máy ảnh có máy đo ánh sáng sẵn nhưng yêu cầu bạn thiết lập tốc độ phim bằng tay.\) Nếu bạn nhìn vào bên trong máy ảnh nơi đặt các cuộn phim, bạn sẽ thấy sáu chỗ tiếp xúc bằng kim loại tương ứng với các ô vuông từ 1 tới 6 trên hộp phim. Các ô bạc thực tế là các phim cát-xét kim loại, đóng vai trò là chất dẫn. Các ô đen là thuốc màu, đóng vai trò là chất cách điện.

Mạch điện trong máy ảnh chạy một dòng điện qua ô vuông 1, cái mà luôn là bạc. Dòng điện này sẽ bị lấy đi \(hoặc không\) bởi năm điểm tiếp xúc trên ô 2 tới ô 6, phụ thuốc vào liệu các ô vuông được tráng bạc hay được phết màu lên. Do đó, nếu máy ảnh có một dòng điện đi qua ô 4 và 5 mà không qua 2, 3 và 6 cuốn phim sẽ là 400 ASA. Máy ảnh có thể điều chỉnh độ phơi sáng của cuốn phim sao cho phù hợp.

Các máy ảnh không đắt lắm cần phải đọc chỉ ô 2 và 3 và cho rằng tốc độ phim là 50, 100, 200 hay 400 ASA.

Đa số các máy ảnh không đọc hay dùng các ô 8 tới 12. Các ô 8, 9 và 10 mã hóa con số phơi sáng trên cuộn phim, và các ô 11 và 12 ám chỉ tới _phạm vi phơi sáng_, mà nó lại dựa trên liệu cuộn phim là cho các bản in trắng đen, cho in màu hay cho các trình chiếu màu.

Có lẽ sự xuất hiện phổ biến nhất của các con số nhị phân là Universal Product Code \(UPC\) được dùng rộng rãi, dãi ký tự mã nhỏ xíu mà xuất hiện trên mỗi bao bì sản phẩm chúng ta mua hằng ngày. UPC xuất hiện để tượng trưng hóa một trong các cách mà máy tính đã len lỏi vào đời sống chúng ta.

Mặc dù UPC thường gây ra các cơn hoang tưởng, nó thật ra là một thứ nhỏ bé ngây thơ, được phát minh cho mục đích quét hàng tự động và kiểm kê, mà nó hoàn thành khá là thành công. Khi nó được dùng với một hệ thống quét mã được thiết kế tốt, khách hàng có thể có một hóa đơn mua hàng, mà không thể có với các máy tính tieenf thông thường.

Điều thú vị với chúng ta ở đây là UPC là mã nhị phân, mặc dù mới nhìn vào thì không giống lắm. Vậy nên sẽ cần phải học để giải mã UPC và kiểm tra cách hoạt động của nó.

Trong hầu hết các dạng thông thường, UPC là một tập hợp của 30 sọc đen thẳng đúng với nhiều kích bê rộng, được chia tách bởi các khoảng trống có bề rộng khác nhau, kèm theo vài con số. Ví dụ, đây là UPC xuất hiện trên lon Campell's Chicken Noodle Soup 10 3/4-ounce:

Chúng ta sẽ thử cố làm sáng tỏ UPC về mặt các thanh ốm và đên, các khoảng trống hẹp và rộng, và thật ra đó là một cách để nhìn vào nó. Thanh đen trong UPC có thể có bốn bề rộng khác nhau, với thanh dày nhất là hai, ba hay 4 lần bề rộng của thanh mỏng nhất. Tương tự, khoảng rộng hơn giữa các thanh là hai, ba hay bốn lần bề rộng của khoảng mỏng nhất.

Nhưng một cách khác để nhìn vào UPC là một dãy các bit. Nhớ trongg đầu là hết cả ký mã dạng thanh này không chính xác với những gì mà đũa phép quét "nhìn thấy" tại quầy thanh toán. Thanh đũa không cố để làm rõ ràng các con số ở dưới đáy, ví dụ, bởi vì nó sẽ cần một công nghệ máy tính tinh vi hơn được biết tới là _máy nhận ra các ký tự quang học_, hay OCR. Thay vào đó, máy quét nhìn thấy chỉ là một lát cắt mỏng của cả khối này. UPC thì to tới cỡ đó là để nhân viên thanh toán có cái gì đó để đưa vào máy quét. Lát cắt mà máy quét nhìn thấy có thể được biểu thị như thế này:

Trông gần giống với mã Morse, phải không?

Khi máy tính quét thông tin này từ trái qua phải, nó gán bit 1 cho thanh đen đầu tiên nó gặp, một bit 0 cho khoảng trống tiếp theo. Chuỗi các khoảng trống và thanh được đọc như là một dãy các bit 1, 2, 3 hay 4 trong một hàng, dựa trên chiều rộng của khoảng trống hay thanh. Tương ứng của mã thanh được quét thành các bit thì đơn giản:

Cho nên cả đoạn mã vạch UPC đơn giản chỉ là một chuỗi 95 bit mà thôi. Trong vị dụ cụ thể này, các bit có thể được nhóm lại như sau:

3 bit đầu luôn luôn là 101. Đây được gọi là _mẫu bảo vệ tay trái_, và nó cho phép thiết bị quét vi tính có thể nhắm đúng được đối tượng. Từ mẫu bảo vệ, mmays quét có theer xác định độ dài mã các thanh và khoảng trống tương ứng với một bit riêng lẻ. Nếu không thì, mã UPC sẽ phải thành một cỡ cụ thể trên tất cả các gói hàng.

Mẫu bảo vệ tay trái được theo sau là sáu nhóm các 7 bit. Mỗi chúng là một mã cho một con số từ 0 tới 9, như tôi vừa mới thử trước đó. Một mẫu  bảo vệ giữa 5 bit đi theo sau. Sự xuất hiện của mẫu cố định này \(luôn là 01010\) là một dạng kiểm tra lỗi đi kèm. Nếu máy quét vi tính không tìm thấy mã bảo vệ giữa nơi mà lẽ ra sẽ có, nó sẽ không chấp nhận mã này là mã UPC. Mẫu bảo vệ trung tâm này là một trong một vài các đề phòng cho mã giả mạo hay được in quá tệ.

Mô hình bảo vệ giữa thì được theo sau bởi sáu nhóm mỗi 7 bit, mà tiếp sau nó là một mô hình mẫu tay phải, luôn luôn là 101. Như tôi sẽ giải thích kỹ hơn, sự hiện diện của mô hình bảo vệ tại khúc cuối cho phép mã UPC được quét ngược \(có nghĩa là, từ phải qua trái\) cũng như xuôi.

Vậy nên toàn bộ UPC được mã hóa thành 12 số. Bên trái UPC mã hóa 6 số, mỗi con yêu cầu 7 bit. Bạn có thể dùng bảng sau để mã hóa những bit này:

Để ý là mỗi mã 7-bit bắt đầu với một số 0 và kết thúc với một số 1. Nếu máy quét gặp một mã 7-bit bên trái mà bắt đầu bằng 1 hay kết thúc bằng 0, thì nó biết rẳng có thể là nó đã không đọc đúng mã UPC hoặc mã đã bị làm giả. Cũng nên đê ý là mỗi mã chỉ có hai nhóm 1 bit liên tiếp. Điều này ngầm hiểu là mỗi con số tương ứng với 2 thanh dọc trong mã UPC.

Bạn sẽ nhận thấy rằng mỗi mã trong bảng này có một số lẻ các bit 1. Đây là một dạng lỗi khác và dạng kiểu tra thống nhất được biết là _parity \(tính chẵn lẻ\)._  Một nhóm các bit có _tính chẵn_ nếu nó có một số chẵn các bit 1 và _tính lẻ_ nếu nó có một số lẻ các bit 1. Do đó, tất cả các mã này có tính lẻ.

Để lý giải sáu mã 7-bit bên phải mã UPC, dùng bảng sau:

Các mã này là các phần bổ túc cho các mã trước đó: cứ nơi nào 0 xuất hiện thì nay thành 1, và ngược lại. Các mã này luôn luôn bắt đầu với một con 1 và kết thúc với 1 con 0. Thêm nữa, chúng có một số chẵn các bit 1, nên sẽ có tính chẵn.

Nào giờ thì chúng ta đã được trang bị để có thể giải mã UPC. Dùng hai cái bảng vừa rồi, chúng ta có thể xác minh là 12 con sỗ được mã hóa trong lon Cambell's Chicken Noodle Soup 10 3/4-ounce là

0 51000 01251 7

Thật thất vọng. Như bạn có thể thấy, các số này giống y đúc các số được in ngay ngắn bên dưới UPC. \(Điều này rất có ý nghĩa nếu máy quét không thể đọc được mã vì lý do nào đó, thì nhân viên thu ngân có thể nhâp số vào bằng tay. Thật sự thì chắc chắn bạn đã gặp cảnh này rồi.\) Chúng ta không phải đi qua hết các công việc giải mã chúng, and hơn nữa, chúng ta vẫn chưa đến gần với việc giải mã bất cứ thông tin bí mật nào. Thế nhưng cũng chẳng còn gì trong UPC để mà giải mã cả. 30 đường dọc ấy phân ra thành 12 con số.

Con số đâu tiên \(0 trong trường hợp này\) được biết đến là _ký tự hệ số_.  Một số 0 có thể hiểu là đây là một mã UPC thông thường. Nếu UPC xuất hiện trên các món đồ tạp hóa trọng-lượng-bất-kỳ như là thịt hay vật dụng, mã sẽ là 2. Mã giảm giá có mã là 5.

Năm con số kế tiếp làm thành mã nhà sản xuất. Trong trường hợp này, 51000 là mã cho công ty Campbell Soup. Tất cả các sản phẩm của Campbell có mã này. Năm con số theo sau \(01251\) là mã cho một sản phẩm cụ thể của công ty, trong trường hợp này, là mã cho một lon súp mì gà 10 3/4-ounce. Mã sản phẩm này có ý nghĩa chỉ khi được kết hợp với mã nhà sản xuất. Một công ty súp mì gà khác có một mã sản phẩm khác và một mã sản phẩm 01251 có thể mang nghĩa gì đó hoàn toàn khác so với nhà sản xuất khác.

Ngược lại với niềm tin phổ biến, UPC không kèm theo cả giá sản phẩm. Thông tin này có được là từ máy tính cửa hàng sử dụng liên kết với máy quét.

Con số cuối cùng \(7 trong trường hợp này\) được gọi là _kí tự kiểm tra đồng dư modulo_. Kí tự này cho phép một dạng kiểm lỗi khác. Để xem xét cách nó làm việc, ta hãy gán mỗi 11 số đầu tiên \(0 51000 01251 trong ví dụ của chúng ta\) cho một chữ cái:

A BCDEF GHIJK

Giờ hãy tính vế sau:

3 x \(A + C + E + G + I + K\) + \(B + D + F + H + J\)

và lấy số bội lớn nhất của 10 tiếp sau trừ đi nó. Đó được gọi là kí tự kiểm tra đồng dư modulo. Trong trường hợp Súp mì gà Campbell, ta có

3 x\( 0 + 1 + 0 + 0 + 2 + 1\) + \(5 + 0 + 0 + 1 + 5\) = 3 x 4 + 11 = 23

Bội lớn nhất của 10 liền kề là 30, vậy nên

30 - 23 = 7 và đó là kí tữ kiểm tra đồng dư modulo được in và mã hóa trong UPC. Đây là một dạng dư. Nếu máy tính điều khiển máy quét không tính ra được kí tứ kiểm tra đồng dư giống cái được mã hóa tong UPC, máy tính sẽ không chấp nhận UPC hợp lệ.

Thông thường, chỉ 4 bit cần để xác định một số thập phân từ 0 tới 9. UPC dùng 7 bit cho 1 số. Tổng quan, UPC dùng 95 bit để mã hóa chỉ 11 con số thập phân hữu dụng. Thật ra UPC bao gồm khoảng trắng \(tương đương với 9 bit 0\) ở cả bên trái và phải của mô hình bảo vệ. Đó có nghĩa là hết cả UPC yêu cầu 113 bit để mã hóa 11 số thập phân, hay trên 10 bit cho một số!

